---
title: "Veronesi Chapter 2 Appendix: Nelson Seigel"
author: "George Fisher"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{"veronesi-ch02-Nelson-Seigel"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---
# Appendix 2.9.3 Curve Fitting   

This appendix makes the point that real-life data is messier than in-class data and the Nelson-Seigel and Svensson models can be used to model Z(0, T) and the price of a bond.   

In this example, Iuse the FedInvest data of 400 daily bond prices as the data to model the yield curve. It turns out that Nelso-Seigel is a lot worse than is shown in the book, at least on this data for the dates I chose.   

The majority of the work was in coercing the FedInvest data into the form required by the *YieldCurve* package I used to create the model parameters.   

```{r, echo=FALSE}
knitr::opts_chunk$set(collapse=TRUE,                # hadley
                      comment = "#>",               # hadley
                      error=TRUE, purl=FALSE,       # to be able to see errors
                      fig.width=7.25, fig.height=6) # nice-sized pictures
```

## Download the FedInvest data and coerce it into an xts time-series data.frame

```{r loadfedinvest, message=FALSE}
library(ustreasuries)
library(magrittr)

# pick a range of dates to analyze
# ================================
start.date <- Sys.Date() - 25
end.date   <- Sys.Date()
# ================================
# ================================

# ==================================================================
# pull the FedInvest data for the range of dates
# ... omitting TIPS, which are weird
# ==================================================================
bond_data <- dplyr::filter(FedInvestData(), Date >= start.date &
                                            Date <= end.date   &
                                            SECURITY.TYPE != "TIPS")

# find the fractional-year time to maturity for each bond
bond_data$fracyrs <- as.numeric((bond_data$MATURITY.DATE - bond_data$Date) / 365)

# the bonds have maturities all over the map, let's regularize them
# 1-month, 3-months, 6-months, years 1-30
# =================================================================
mo1 = c(0,                   1/12+(3/12-1/12)/2)
mo3 = c(1/12+(3/12-1/12)/2,  3/12+(6/12-3/12)/2)
mo6 = c(3/12+(6/12-3/12)/2,  6/12+(12/12-6/12)/2)
yr1 = c(6/12+(12/12-6/12)/2, 1+(2-1)/2)
breaks = list(mo0.08333333=mo1, mo0.25=mo3, mo0.5=mo6, yr1=yr1)
for (i in seq(2,30)) {
    breaks[[i+3]] <- c((i-1) + ((i)-(i-1))/2, (i) + ((i+1)-(i))/2)
}
names(breaks) <- c("mo0.08333333", "mo0.25", "mo0.5", "yr1", paste0("yr",seq(2,30)))

maturities = unlist(sapply(bond_data$fracyrs, function(x) {
    for (i in 1:length(breaks)) {
        if (x >= breaks[[i]][1] & x <= breaks[[i]][2]) {
            return(as.numeric(substr(names(breaks[i]),3,nchar(names(breaks[i])))))
        }
    }
}))
bond_data$maturities <- maturities
# =================================================================

# create the fractional coupons
# =============================
matches <- regexpr("(\\d+\\.\\d+)%", bond_data$RATE, perl=TRUE);
result  <- attr(matches, "capture.start")[,1]
attr(result, "match.length") <- attr(matches, "capture.length")[,1]
bond_data$coupon <- as.numeric(regmatches(bond_data$RATE, result))/100


# for each set of bonds
#   on a date
#     with the same regularized maturity
# find the average YTM in percentage format
# ===========================================
rate_table <- bond_data %>%
    dplyr::group_by(Date, maturities) %>%
    dplyr::summarise(ytm=mean(jrvFinance::bond.yields(settle=Date,
                                                      mature=MATURITY.DATE,
                                                      coupon=coupon,
                                                      price=END.OF.DAY))) %>%
    tidyr::spread(maturities, ytm)

# if Newton-Raphson and Bisection failed  to find IRR/YTM
# ... remove the rows
rate_table <- rate_table[complete.cases(rate_table),]

# convert to xts format
rate_table_xts <- xts::xts(rate_table[,-c(1)], order.by = rate_table$Date)

# get the vector of regularized maturities
unique_maturities <- as.numeric(names(rate_table_xts))

# one row per day; each column the average YTM of a maturity
rate_table_xts[1:3, 1:5]
```   

## Download the CMT data for comparison

```{r cmtdownload}
# ==================================================================
# pull the CMT rates for a representative date in the selected range
# to use as a check on how good the models are
# ==================================================================
CMT_data <- CMTrates()
for (date in seq(start.date, end.date, by=1)) {
    CMT_date <- as.Date(date, origin="1970-01-01")
    if (weekdays(CMT_date) %in% c("Monday","Tuesday","Wednesday","Thursday","Friday") &
        which(CMT_date==seq(start.date, end.date, by=1)) >=
              length(seq(start.date, end.date, by=1))/2 &
        CMT_date%in% CMT_data$NEW_DATE)
        break
}
CMT_y <- sapply(dplyr::filter(CMT_data, NEW_DATE==CMT_date)[3:13],
                function(x) x[[1]]/100)
CMT_y[1:5]
```

## Apply Nelson Seigel

```{r NS}
# =============
# Nelson Siegel
# =============

NSParameters <- YieldCurve::Nelson.Siegel(rate= rate_table_xts, maturity=unique_maturities)
NSParameters[1:3,]

NSrates <- function(parameters, maturities=c(1/12, 3/12, 6/12, 1, 2, 3, 5, 7, 10, 20, 30)) {
    #
    # this function uses the Nelson-Seigel formula to model the
    # CMT rates.
    #
    
    parameters <- as.numeric(parameters)
    beta0  <- parameters[1]
    beta1  <- parameters[2]
    beta2  <- parameters[3]
    lambda <- parameters[4]

    rate_list <- c()
    i <- 1
    for (t in maturities) {
        rate_list[i] <- beta0 + (beta1 + beta2) *
            ((1 - exp(-t/lambda)) / (t/lambda)) -
            beta2*exp(-t/lambda)
        i <- i + 1
    }
    return(rate_list)
}

mid_parm <- ceiling(nrow(NSParameters)/2)
NS_y     <- NSrates(NSParameters[mid_parm,])

plot(x=1:11, y=NS_y,
     ylim=c(min(NS_y,CMT_y),max(NS_y,CMT_y)),pch=19,type="b",lty=1,
     ylab="Yield",xlab=NA,xaxt="n",
     main=paste0("Term Structure on ",CMT_date, " Actual and Modeled by Nelson Siegel"))

points(x=1:11, y=CMT_y, pch=10)
lines(x=1:11,  y=CMT_y, lty=2)

legend("topleft",legend=c("Nelson Siegel Model based on FedInvest Data",
                          "CMT Rates from the Treasury"),
       pch=c(19,10), lty=c(1,2))

axis(1, at     = axTicks(1),
     labels = substr(names(CMT_y)[axTicks(1)],4,9))
grid()
```

## Svensson

```{r sv}
# ========
# SVENSSON
# ========

SVParameters <- YieldCurve::Svensson(rate= rate_table_xts, maturity=unique_maturities)
SVParameters[1:3,]

SVrates <- function(parameters, maturities=c(1/12, 3/12, 6/12, 1, 2, 3, 5, 7, 10, 20, 30)) {
    #
    # use the Svensson model parameters to model the yield curve
    #
    parameters <- as.numeric(parameters)
    beta0  <- parameters[1]
    beta1  <- parameters[2]
    beta2  <- parameters[3]
    beta3  <- parameters[4]
    lambda1 <- parameters[5]
    lambda2 <- parameters[6]

    rate_list <- c()
    i <- 1
    for (t in maturities) {
        rate_list[i] <- beta0 + (beta1 + beta2) *
            ((1 - exp(-t/lambda1)) / (t/lambda1)) -
            beta2*exp(-t/lambda1) +
            beta3*(-exp(-t/lambda2) + (1-exp(-t/lambda2)) / (t/lambda2))
        i <- i + 1
    }
    return(rate_list)
}

mid_parm <- ceiling(nrow(SVParameters)/2)
SV_y     <- SVrates(SVParameters[mid_parm,])

plot(x=1:11, y=SV_y,
     ylim=c(min(SV_y,CMT_y),max(SV_y,CMT_y)),pch=19,type="b",lty=1,
     ylab="Yield",xlab=NA,xaxt="n",
     main=paste0("Term Structure on ",CMT_date, " Actual and Modeled by Svensson"))

points(x=1:11, y=CMT_y, pch=10)
lines(x=1:11,  y=CMT_y, lty=2)

legend("topleft",legend=c("Svensson Model based on FedInvest Data",
                          "CMT Rates from the Treasury"),
       pch=c(19,10), lty=c(1,2))

axis(1, at     = axTicks(1),
     labels = substr(names(CMT_y)[axTicks(1)],4,9))
grid()


```
